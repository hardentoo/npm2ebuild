#!/usr/bin/env node
/**
 * \brief Read NPM package info and produce a Gentoo ebuild skeleton.
 *
 * This stupid^Wsimple program aimed to help me to write ebuilds for
 * NPM packages. [There is][neurogeek] a eclass for that I've found and
 * improve a little which helps a lot.
 *
 * \attention Review the log generated and pay attention to warnings!
 * This program far from good (yeah, just initial (naive) implementation).
 *
 * [neurogeek]: git://anongit.gentoo.org/dev/neurogeek.git
 */

var npm = require('npm');
var fs = require('fs');
var mustache = require('mustache');
var semver = require('semver');
var argv = require('argv');
var mkdirp = require('mkdirp');

// Declare program options
var options = {
    name: 'output-path'
  , short: 'o'
  , type: 'path'
  , description: 'Output path to write ebuilds hierarchy'
};

var args = argv.option(options).run();
// console.log("%j", args);

if (!args.targets.length)
{
    console.log('No package(s) given');
    process.exit(0);
}

/// \todo Avoid hardcode
var EBUILD_TEMPLATE = fs.readFileSync('./templates/ebuild.template');
var seen_packages = [];

/// Helper function to render ebuild
function handle_package(info)
{
    // Transform dependencies into array and produce ebuilds for them
    // (to avoid second iteration later on same hash ;-)
    var dependencies = [];
    if (info.hasOwnProperty('dependencies'))
    {
        Object.keys(info.dependencies).forEach(
            function(key)
            {
                var version = null;
                var operation = '';

                var match = /(^|~|>|>=)?\s*([\w.]+)/.exec(info.dependencies[key]);
                if (match)
                {
                    // Try to use semver parser to validate version
                    if (semver.valid(match[2]))
                    {
                        version = match[2];
                    }
                    else if (match[2].indexOf('x') != -1)
                    {
                        version = match[2].replace('x', '*');
                        console.log('*** NOTE: Found wildcard version: %s -> %s', match[2], version);
                    }
                    else
                    {
                        console.log('*** ATTENTION: version parse error on "%s"', info.dependencies[key]);
                        version = null;
                    }
                    if (match[1] === '>=' || match[1] === '~' || match[1] === '^')
                    {
                        operation = '>=';
                    }
                    else if (version)
                    {
                        operation = '=';
                    }
                }

                // console.log('    %s %s %j', key, info.dependencies[key], version);
                dependencies.push({
                    name: key
                  , version: version
                  , op: operation
                  });
                // Produce ebuilds for dependencies
                produce_ebuilds(key);
            }
          );
    }

    // Transfrom binary files list into array
    var bin_files = [];
    var has_bin_files = false;
    if (info.hasOwnProperty('bin'))
    {
        Object.keys(info.bin).forEach(
            function(symlink_name)
            {
                bin_files.push({
                    symlink_name: symlink_name
                  , name: info.bin[symlink_name]
                  });
            }
          );
        has_bin_files = true;
    }

    var required_nodejs_version = '0.10';
    var required_nodejs_version_op = '>=';
    if (info.hasOwnProperty('engines'))
    {
        Object.keys(info.engines).forEach(
            function(key)
            {
                if (key == 'node')
                {
                    var match = /(^|~|>|>=)?\s*([\w.]+)/.exec(info.engines[key]);
                    if (match)
                    {
                        var version = match[2];
                        if (semver.valid(version))
                        {
                            required_nodejs_version = version;

                            if (match[1] === '>=' || match[1] === '~' || match[1] === '^')
                                required_nodejs_version_op = '>=';
                            else
                                required_nodejs_version_op = '=';
                        }
                    }
                }
            }
          );
    }

    // Prepare data for rendering template
    var ebuild_data = {
        name: info.name
      , version: info.version
      , description: info.description
      , homepage: info.homepage
      , license: info.license
      , dependencies: dependencies
      , has_bin_files: has_bin_files
      , bin_files: bin_files
      , required_nodejs_version: required_nodejs_version
      , required_nodejs_version_op: required_nodejs_version_op
    };

    // Make some spam
    // console.log("%j", info);
    console.log("---[BEGIN %s %s]---", info.name, info.version);
    console.dir(ebuild_data, {colors: true});
    console.log("---[END %s %s]---\n", info.name, info.version);

    var ebuild_dir = (args.options['output-path'] ? args.options['output-path'] + '/' : './')
      + 'dev-nodejs/' + info.name + '/';
    mkdirp(
        ebuild_dir
      , function(err)
        {
            var output = mustache.render(EBUILD_TEMPLATE.toString(), ebuild_data);
            fs.writeFile(ebuild_dir + info.name + '-' + info.version + '.ebuild', output);
        }
      );

    var raw_json_dir = (args.options['output-path'] ? args.options['output-path'] + '/' : './')
      + 'packages-data/';
    mkdirp(
        raw_json_dir
      , function(err)
        {
            fs.writeFile(raw_json_dir + info.name + '-' + info.version + '.json', JSON.stringify(info, null, 2));
        }
      );
}

/// Retrieve package JSON data and produce ebuild for given name
function produce_ebuilds(package_name)
{
    if (seen_packages.indexOf(package_name) != -1)
    {
        console.log('*** NOTE: Skip %s package cuz already made/scheduled ebuild for it', package_name);
        return;
    }

    npm.load(
        function (er)
        {
            if (er)
                return handlError(er);

            npm.commands.view(
                [package_name]
              , true
              , function(er, data)
                {
                    if (er)
                        return commandFailed(er);
                    // command succeeded, and data might have some info
                    handle_package(data[Object.keys(data)[0]]);
                }
              );
        }
      );

    seen_packages.push(package_name);
}

// Iterate over requested package names and produce ebuilds
args.targets.forEach(produce_ebuilds);

// kate: hl javascript;
